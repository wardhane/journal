[{"content":"Welcome to my technical blog. In this blog, we will dive into the inner workings of Cassandra, the popular, high-performance, and highly-scalable distributed database system. We will explore how it handles read requests from clients. We will cover topics such as how Cassandra achieves its high level of availability, how it routes read requests to the appropriate node, and how it handles situations where a node does not have a replica of the requested data. By the end of this blog, you will have a solid understanding of how reads work in Cassandra and how it helps to ensure a fast and reliable experience for users. So, let\u0026rsquo;s get started!\nCassandra enables clients to access data from any node, even if that node doesn\u0026rsquo;t have a replica of the requested data. In these instances, the node without the data acts as a coordinator, retrieving the data from nodes that do have it. Cassandra reads can be slower than writes because of file I/O, particularly when data needs to be fetched from disk. However, read performance can be improved through caching, increasing the number of nodes, and using node memory to read the data. As a result, data can be retrieved and returned to the client in Cassandra either from the cache, memory, or disk.\nData storage in Cassandra Cassandra uses LSM (Log-structured Merge Trees) to persist its data, which is similar to databases such as RocksDb and LevelDb. This is different from traditional RDBMSs, which typically use a B-tree implementation. To ensure durability, Cassandra also writes data to a commit log, similar to a Write-Ahead Log (WAL) and writes to memory as well.\nEach table in Cassandra has an associated in-memory table. As data is written to the commit log in a sequential order, it is sorted by the partition key and clustering key and stored within the in-memory table. The partition key determines which node the data is stored on, and the clustering key determines the order in which it is stored on that node. The primary key for Cassandra is effectively composed of the partition key and the clustering key. When the in-memory table reaches its optimal size, determined by the chunk size of the data, it is saved to disk as an SSTable (Sorted String Table). This table contains a data file and an index file, both of which include in-memory indexes. Regular compaction is performed by merging and rewriting SSTables which reduces disk space and improves read performance by removing outdated data and consolidating it into fewer, larger SSTables.\nData retrieval on a single node follows a similar path with a few optimisations.\nRead path on a single node Reading from Cache Cassandra uses several types of caches to improve read performance.\n  Row Cache: This cache stores the most recent data for a table in memory, allowing for fast access to frequently-accessed data. It is useful for read-heavy workloads and can take considerable amount of space.\n  Key Cache: This cache stores the keys of recently-accessed rows in memory, allowing for faster lookups. It is useful for write-heavy workloads. In essence, it is a cache of the PartitionIndex file for a table which is a map of partition keys to their SSTable offsets.\n  Counter Cache: This cache stores the most recent counter values in memory, improving the performance of counter-related operations.\n  File System Cache: This cache stores data read from disk in memory, allowing for faster access to data that is not already stored in the row or key cache.\n  All of these caches can be configured with different sizes, depending on the available memory and the specific use case. The caches can also be disabled if not needed.\nIt\u0026rsquo;s important to note that caching in Cassandra is optional, and enabling it depends on the use case and the amount of memory available. Cassandra distributes the cache data across the cluster. When a node goes down , the client can read from a cache replica. The distributed cache in cassandra is saved periodically into disk which helps read data into cache on start up. Also, one of the important point is that, if the data is changing frequently, caching may not always improve performance as it will store stale data.\nReading from Disk Cassandra reads data from disk using the SSTable data structure. The SSTables are organized on disk as a set of data files, each containing a portion of the data stored in Cassandra. SSTables are immutable, meaning that once written, they are not updated. Instead, when data changes, a new SSTable is written to disk, allowing Cassandra to maintain an ordered view of the data.\nThe choice of SSTable as a data structure helps improve sequential access of data by leveraging its design as a sorted and indexed file. When reading data, Cassandra performs a binary search on the SSTable index, which is stored in memory, to quickly locate the on-disk position of the desired data. From there, Cassandra can perform a sequential read of the data, since the SSTable data is stored in sorted order on disk.\nThis design allows Cassandra to perform highly optimized and efficient disk access, enabling it to handle very large data sets with low latency. Additionally, because SSTables are immutable, they can be safely and efficiently compressed, further reducing disk usage and improving performance.:\nThe partition index and partition index summary files are two key components in Cassandra\u0026rsquo;s data storage architecture.\nThe partition index is a file that stores the metadata for each partition of data stored in an SSTable. This metadata includes the starting and ending row keys for each partition, as well as the on-disk position of the data. The partition index is used by Cassandra to efficiently locate partitions when reading data from disk.\nThe partition index summary file is a smaller, compressed version of the partition index. It contains a sample of the entries from the full partition index, rather than all of them. This allows Cassandra to quickly locate the on-disk position of the data for a given partition, without having to read the full partition index. The partition index summary file is loaded into memory, making it readily available for fast lookups.\nTogether, the partition index and partition index summary files form a key part of Cassandra\u0026rsquo;s data storage architecture, enabling it to efficiently locate and access data on disk, even in very large data sets.\nThe below diagram shows a partition Index file and its corresponding data file.\nand the relationship between Partition Index Summary File and Partition Index file is shown below\nSummary  Cassandra being a distributed data base with multiple replicas needs to optimise the read path to be performant A read query that comes to a node without data will act as a co-ordinator node and request data from the adjacent nodes. The read consistency setting will have an impact on the overall read performance. On a node data can be retrieved either from cache or from disk There are many types of cache available are row-cache, key-cache, counter-cache and file cache. If the data is not found on cache, then an in memory bloom filter is checked to see if the data exists on the disk. If data exists on disk, then the partition index summary file is used to identify the offset on the partition index file. The byte offset of the partition key is fetched from the partition index file using the offset from the partition index summary file. OS caching of the partition index file can further improve the seek performance. Data is read from the data file using the byte offset of the partition key.  ","permalink":"https://wardhane.github.io/journal/posts/reads-in-cassandra/","summary":"Cassandra is a widely used NoSQL database that prioritizes high scalability and high availability over consistency. This article delves into the inner workings of reads in Cassandra and how it leverages various techniques to improve read performance. The article covers key topics such as Cassandra\u0026rsquo;s datastore architecture. The article provides a comprehensive overview of how Cassandra manages read requests, how it ensures fast access to data, and how it balances the trade-off between read performance and consistency.","title":"Reads in Cassandra"},{"content":"Hi there! I\u0026rsquo;m thrilled you\u0026rsquo;re visiting my learning journal. I\u0026rsquo;m passionate about learning and am excited to share my knowledge and experiences with a wider audience.\nBefore joining Maersk, I spent over a decade at Schlumberger where I started as a software engineer and progressed to become an architect, leading teams and driving innovative projects. During my time at Schlumberger, I honed my technical skills and developed a strong foundation in software development and team leadership.\nI\u0026rsquo;m currently employed at Maersk where I have the privilege of heading their Customer Identity Platform. My role has allowed me to acquire new technical skills in Forgerock, IBM Cloud, and running production workloads on Kubernetes. I have also gained valuable experience using Kafka for eventing and Cassandra for distributed storage.\nThrough my journey with Maersk, I\u0026rsquo;ve developed a deep appreciation for the challenges that come with building and maintaining a highly available platform. In my joureny with Maersk, I have ventured into the world of management, starting as an SRE Manager and am now serving as a full-time Engineering Manager, leading multiple teams distributed globally.\nI\u0026rsquo;m always striving to expand my knowledge and skillset, and I\u0026rsquo;m eager to share my learnings with others. I believe that management is a critical component of successful engineering teams, and I\u0026rsquo;m dedicated to supporting my teams and fostering a positive and productive work environment.\nI hope that you find my learning journal informative and inspiring, and I look forward to connecting with you!\n","permalink":"https://wardhane.github.io/journal/posts/about/","summary":"Hi there! I\u0026rsquo;m thrilled you\u0026rsquo;re visiting my learning journal. I\u0026rsquo;m passionate about learning and am excited to share my knowledge and experiences with a wider audience.\nBefore joining Maersk, I spent over a decade at Schlumberger where I started as a software engineer and progressed to become an architect, leading teams and driving innovative projects. During my time at Schlumberger, I honed my technical skills and developed a strong foundation in software development and team leadership.","title":"About me"},{"content":"Introduction One of my ambitions is to share content more often, but I often struggle with proofreading and capturing my ideas. I believe that my content is not perfect enough to be shared with a wider audience, which hinders my ability to share it. When I do have an idea for a blog, I often don\u0026rsquo;t have the time to record it because I\u0026rsquo;m in the middle of another activity. Even when I do have the time, I find it difficult to structure the content to a level that I feel is fit to share. To overcome these challenges and build a habit of sharing content, I plan to create a mobile app that captures speech and translates it to text. The app will then display the text on the screen and send it to OpenAI for proofreading and formatting. Once complete, the app can publish the content to GitHub.\nSystem Design  Mobile Client: The client is a mobile or web UI that will be responsible for recording the user and presenting to the user the text and audio representation of their recent recording. Speech to text converter: The speech to text converter will be an API that will access the audio snippets stored by the client in a secure location and transcribe them into text. Text editor: Reviews the transcribed text, edits, refines and structures it. This is not a UI component but an AI component that is focused on re-structuring and re-formatting the content. Publisher: Synchronises and allows you to publish the content to github  Setup Client The client is a mobile app built using Flutter, an open-source mobile application framework created by Google. Flutter enables developers to to build cross-platform mobile apps for Android and iOS using a single codebase. One of the key benefits of Flutter is its hot reload feature, which allows developers to quickly iterate on their code and see the changes in real-time. This makes it easier to fix bugs and add new features. Flutter also offers a wide range of built-in widgets and tools for building attractive and responsive user interfaces. Additionally, its support for testing and continuous integration will enable me to deliver a quality app when it is released.\nThis post will not be a deep dive into Flutter development. Time permitting, I will write another article that focuses on my journey into flutter development. For the client, we are looking at targetting Android and IoS.\nThe docs for flutter are pretty extensive and you can install flutter by following the directions here. I am using macOS and the screen shots here-on will reflect the setup and instructions for a mac. flutter doctor is a command that validates your install and you should see something similar to the below screen\n","permalink":"https://wardhane.github.io/journal/posts/dictation/","summary":"Introduction One of my ambitions is to share content more often, but I often struggle with proofreading and capturing my ideas. I believe that my content is not perfect enough to be shared with a wider audience, which hinders my ability to share it. When I do have an idea for a blog, I often don\u0026rsquo;t have the time to record it because I\u0026rsquo;m in the middle of another activity. Even when I do have the time, I find it difficult to structure the content to a level that I feel is fit to share.","title":"Speak Easy: From Speech to Text with AI"}]